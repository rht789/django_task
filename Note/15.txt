15 Class based Views

15.1 : Intro to CBV
Class based views are a special view which can be created by using class, its an alternative of function based class, where reusability is easy and also we get the benefits of inheritance,

CBVs are particularly useful for:

Reducing code duplication.
Handling common patterns (e.g., displaying a list of objects or editing a form).
Providing a clean, reusable structure for complex views.

basic structure of cbvs:
from django.views import View
from django.http import HttpResponse

class MyView(View):
    def get(self, request, *args, **kwargs):
        return HttpResponse("Hello, this is a GET request!")
    
    def post(self, request, *args, **kwargs):
        return HttpResponse("Hello, this is a POST request!")

15.2 Reusability of Class-Based views
lets see and example of reusability:

in views.py:
from django.http import HttpResponse
from django.views import View

# Base Class
class GreetingView(View):
  greeting = "Good Day" # Class Attributes

  def get(self, request):
    return HttpResponse(self.greeting)

now if we want to create subclassing then it will be:
from django.http import HttpResponse
from django.views import View

# Base Class
class GreetingView(View):
  greeting = "Good Day" # Class Attributes

  def get(self, request):
    return HttpResponse(self.greeting)

class MorningGreetingView(GreetingView):
  greeting = "Morning to ya" 

so here we created another class but inherited the base class GreetingView to use its greeting variable, bnow to to use this we need to put the urls too, so in urls.py:

from .views impoer GreetingView,MorningGreetingView

urlpatterns = [
	path('greetings', GreetingView.as_view()),
	path('morning-greetings', MorningGreetingView.as_view())
]

now if we don't want to create subclassesand want to use the base classes component in url we can write :
from django.urls import path
from .views import GreetingView

# URLconf (urls.py)
urlpatterns = [
  path('greeting/', GreetingView.as_view(greeting="Hello there!")), 
]

15.3 Converting Function Views to Class Based View
now we will convert one of our function based view into class based view, so we will convert the create task view from,
def create_task(request):
    task_form = TaskModelForm()
    taskdetail_form = TaskDetailModelForm()
    if request.method == "POST":
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task')                
    context = {
        "task_form" : task_form,
        "taskdetail_form" : taskdetail_form
    }
    return render(request,'task_form.html', context)

to,
class CreateTask(View):
    def get(self,request,*args,**kwargs):
        task_form = TaskModelForm()
        taskdetail_form = TaskDetailModelForm()   
        context = {
        "task_form" : task_form,
        "taskdetail_form" : taskdetail_form
        }
        return render(request,'task_form.html', context) 
    
    def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task')

and in urls from path('create_task/', create_task, name='create_task') to path('create_task/', CreateTask.as_view(), name='create_task')

now theres a issue, we can't use function based decorators directly in classbased views, there are multiple way to use a decorator, first we can use them in urlsdirectly like this path('create_task/', login_required(CreateTask.as_view()), name='create_task'), but f we have to provide multiple restrictions then we would need to write those in this way for each decorator which is not preferable, second one is using "method_decorators", it can be used in the method of the CBV's, for example  using on our get or post method, like: 
@method_decorator(login_required)
def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task')  
third using method required above the class, but we would need to mention at which class we would want to use, before that lets understand a new method dispatch, its a built in method in View class (the parent of all CBV), it decides where to send an incoming HTTP request (like GET or POST) and makes sure everything runs smoothly.
so above class we would write @method_decorator(login_required, name="dispatch"), meaning in dispatch check if the user is logged in or not then send the http request to post or get, This ensures the entire view requires login, like this :
@method_decorator(login_required,name='dispatch')
class CreateTask(View):
    
    template_name = 'task_form.html'
    def get(self,request,*args,**kwargs):
        task_form = TaskModelForm()
        taskdetail_form = TaskDetailModelForm()   
        context = {
        "task_form" : task_form,
        "taskdetail_form" : taskdetail_form
        }
        return render(request,self.template_name, context) 
    
    def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task')  

we can wrte multiple decorator here too, but if we have multiple decorators to use then best will be put them in a list then use that list in method_decorator, so we declared a list outside the class and used it it in our CBV, 
create_decorators = [login_required,permission_required("tasks.add_task", login_url='no-permission')]

@method_decorator(create_decorators,name='dispatch')
class CreateTask(View):
    
    template_name = 'task_form.html'
    def get(self,request,*args,**kwargs):
        task_form = TaskModelForm()
        taskdetail_form = TaskDetailModelForm()   
        context = {
        "task_form" : task_form,
        "taskdetail_form" : taskdetail_form
        }
        return render(request,self.template_name, context) 
    
    def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task') 
15.4 Mixins
Now we have told there are many way to use decorators, one of those is Mixins, Mixins are python class that provides specific methods or attributes but designed to combined with other classes, there are somebuiltin mixins like LoginRequiredMixins, PermissionRequiredmixins etc, AccessMixins
weneed to inherit in  our CBV to use their functionality for instance we used login and permisiion decorator in our function based views previously  now to use them in CBV we need toinherit those mixins maintaining MRO, where loginRequiredMixins must come at left, here is the example:
class CreateTask(LoginRequiredMixin,PermissionRequiredMixin,View):
    
    login_url='sign-in'
    permission_required='tasks.add_task'
    template_name = 'task_form.html'
    def get(self,request,*args,**kwargs):
        task_form = TaskModelForm()
        taskdetail_form = TaskDetailModelForm()   
        context = {
        "task_form" : task_form,
        "taskdetail_form" : taskdetail_form
        }
        return render(request,self.template_name, context) 
    
    def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        taskdetail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and taskdetail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            taskdetail = taskdetail_form.save(commit=False)
            taskdetail.task = task
            taskdetail.save()
            messages.success(request, "Task Created Successfully")
            return redirect('create_task')
so here login will be checked in at dispatch first then permission required will be checked, login_url and permission_required attributes are from mixins, we just override them

Now we can also make our context data meaningful , instead of writing the context again and again we would put it in a kwargs and use them whenever we need them, 
class CreateTask(ContextMixin,LoginRequiredMixin,PermissionRequiredMixin,View):
    
    login_url='sign-in'
    permission_required='tasks.add_task'
    template_name = 'task_form.html'
    
    def get_context_data(self, **kwargs):
        context=super().get_context_data(**kwargs)
        context["task_form"] = kwargs.get('task_form', TaskModelForm())
        context["task_detail_form"] = kwargs.get('task_detail_form', TaskDetailModelForm())
    
    def get(self,request,*args,**kwargs): 
        context = self.get_context_data()
        return render(request,self.template_name, context) 
    
    def post(self,request,*args,**kwargs):
        task_form = TaskModelForm(request.POST)
        task_detail_form = TaskDetailModelForm(request.POST, request.FILES)
        if task_form.is_valid() and task_detail_form.is_valid():
            """For Django model Form"""
            task = task_form.save()
            task_detail = task_detail_form.save(commit=False)
            task_detail.task = task
            task_detail.save()
            messages.success(request, "Task Created Successfully")
            context = self.get_context_data(task_form=task_form, task_detail_form=task_detail_form)
            return render(request,self.template_name, context)  

here in get method if user have just load the page then TaskModelForm and TaskDetailModelForm instance will be created or if user just created a task then the info of that task will be present their, and in post method we are sending those tasks info in context
