11 Django Signals
11.1 Introduction to Signals
Django signals are a powerful feature in the Django framework that allow different parts of an application to communicate with each other without being tightly coupled. They enable actions to be triggered when specific events occur, such as saving or deleting a model instance, user authentication, or custom events defined by the developer.
Common Django models signals:
pre_save
When it’s sent: Just before an object is saved to the database (before the .save() method commits the changes).
Arguments:
sender: The model class (e.g., Task).
instance: The instance being saved.
raw: Boolean indicating if the instance is saved as raw (e.g., via fixtures).
using: The database alias being used.
update_fields: A set of fields being updated (if specified in .save()).

from django.db.models.signals import post_save,pre_save
from django.dispatch import receiver
@receiver(pre_save,sender = Task)
def notify_task_creation(sender,instance, **kwargs):
    print("sender", sender)
    print("instance", instance)
    instance.is_completed = True

b. When it’s sent: Just after an object is saved to the database.
Arguments:
Same as pre_save, plus:
created: Boolean indicating if the instance was created (True) or updated (False).
@receiver(post_save,sender = Task)
def notify_task_creation(sender,instance,created, **kwargs):
    print("sender", sender)
    print("instance", instance)
    print(created)
    if created:
        instance.is_completed = True
        instance.save()
c. pre_delete
When it’s sent: Just before an object is deleted from the database.
Arguments:
sender: The model class.
instance: The instance being deleted.
using: The database alias.

d. post_delete
When it’s sent: Just after an object is deleted from the database.
Arguments: Same as pre_delete.
Use Case: Perform post-deletion tasks, like notifying users.

e. pre_init
When it’s sent: Before a model’s __init__ method is called.
Arguments:
sender: The model class.
args: Positional arguments passed to __init__.
kwargs: Keyword arguments passed to __init__.
Use Case: Rarely used, but could modify initialization behavior.

f. post_init
When it’s sent: After a model’s __init__ method is called.
Arguments: sender and instance.
Use Case: Set up instance-specific data after creation.

g. m2m_changed
When it’s sent: When a ManyToManyField (like Task.assigned_to) is modified.
Arguments:
sender: The through model of the ManyToManyField.
instance: The instance whose M2M field changed.
action: String indicating the change (pre_add, post_add, pre_remove, post_remove, pre_clear, post_clear).
reverse: Boolean indicating the direction of the relation.
model: The model class of the objects being added/removed.
pk_set: Set of primary keys being added/removed.
Use Case: React to changes in assigned employees.

8.2 m2m implementation in our task management:
at first we need to setup email related configuration to use googles smt server to send email, we need to add this in settings.py:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_USE_TLS = True
EMAIL_PORT = 587
EMAIL_HOST_USER = "rahatrezaulkarim@gmail.com"
EMAIL_HOST_PASSWORD = "eeoo viob elfm ffot"

then in models.py we need to create the function:
@receiver(m2m_changed, sender=Task.assigned_to.through)
def notify_employees_on_task_creation(sender, instance, action, **kwargs):
    if action == 'post_add':
        print(instance, instance.assigned_to.all())
        assigned_emails = [emp.email for emp in instance.assigned_to.all()]
        print("Checking....", assigned_emails)
        send_mail(
            "New Task Assigned",
            f"You have been assigned to the task: {instance.title}",
            "rahatrezaulkarim@gmail.com",
            assigned_emails,
            fail_silently=False,
        )

here @receiver(m2m_changed, sender=Task.assigned_to.through):
Registers the function to listen for m2m_changed signals.
sender=Task.assigned_to.through: Specifies the intermediate table (auto-generated by Django) that manages the Task.assigned_to ManyToMany relationship. This is necessary because m2m_changed is emitted by the through table, not Task directly.
notify_employees_on_task_creation(sender, instance, action, **kwargs):
sender: The through model (e.g., tasks_task_assigned_to), though you rarely use it directly.
instance: The Task object whose assigned_to field is being modified.
action: A string indicating the type of change (e.g., 'post_add', 'post_remove', 'pre_clear').
**kwargs: Additional arguments like pk_set (IDs of changed employees), which you’re not using here.

assigned_emails = [emp.email for emp in instance.assigned_to.all()]:
Creates a list of email addresses from all employees currently assigned to the task.
send_mail(...):
Subject: "New Task Assigned".
Message: A simple string with the task title (e.g., "You have been assigned to the task: Finish Report").
From: "rahatrezaulkarim@gmail.com" (your Gmail address).
To: assigned_emails (list of recipient emails).
fail_silently=False: Raises an exception if email sending fails (useful for debugging).

the send_mail format is :
# Send email to all assigned employees
        send_mail(
            subject=subject,
            message=message,
            from_email=from_email,
            recipient_list=recipient_list,
            fail_silently=False,  # Set to True in production to avoid crashes on email failure
        )
8.3 Post delete
at first changed our taskdetail where on_delte has been changed from cascade to do_nothing and this is the code of our signal:
@receiver(post_delete,sender=Task)
def delete_associate_details(sender,instance,**kwargs):
    if instance.details:
        print(instance)
        instance.details.delete()
        print("Task Deleted Successfully")
11.4 : environ variables

added environment variables for security and data integrity
at first we need to install python decouple package and then create .env file in root folder and add this :
SECRET_KEY=django-insecure-$rd=2j6n#fm^=3)l4nqmnc#*kosg(2k_fup22zay_(e!-1zb4w

#db
DB_NAME=task_management
DB_USER=postgres
DB_PASSWORD=1234
DB_HOST=localhost
DB_PORT=5432

#email

EMAIL_HOST=smtp.gmail.com
EMAIL_USE_TLS=True
EMAIL_PORT=587
EMAIL_HOST_USER=rahatrezaulkarim@gmail.com
EMAIL_HOST_PASSWORD=eeoo viob elfm ffot



then in settings.py we need to import config from decouple and just add config('field name in env file'), here is full updated settings.py:
from pathlib import Path
from decouple import config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config("SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "tasks",
    "users",
    "core",
    "debug_toolbar"
]

MIDDLEWARE = [
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

INTERNAL_IPS = ["127.0.0.1"]

ROOT_URLCONF = "task_management.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / 'templates'],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "task_management.wsgi.application"

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': config('DB_NAME', default=''),
        'USER': config('DB_USER', default=''),
        'PASSWORD': config('DB_PASSWORD', default=''),
        'HOST': config('DB_HOST', default='localhost'),
        'PORT': config('DB_PORT', cast=int)
    }
}

# Mail
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = config('EMAIL_HOST')
EMAIL_USE_TLS = config('EMAIL_USE_TLS', cast=bool)
EMAIL_PORT = config('EMAIL_PORT')
EMAIL_HOST_USER = config('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD')

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True

STATIC_URL = "static/"
STATICFILES_DIRS = [BASE_DIR / 'static/']

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

and don't forget to add .env in gitignore file

11.5 send user activation email

users app signals.py:
# users/signals.py
from django.dispatch import receiver
from django.db.models.signals import post_save
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator
from django.conf import settings
from django.core.mail import send_mail

@receiver(post_save, sender=User)
def send_activation_mail(sender, instance, created, **kwargs):
    if created:
        token = default_token_generator.make_token(instance)
        activation_url = f"{settings.FRONTEND_URL}/users/activate/{instance.id}/{token}"
        subject = f'Activate Your Account'
        message = f'Hi {instance.username}, \\n\\n Please click this link to activate your account: \\n\\n {activation_url}\\n\\n Thank you.'
        receipent_list = instance.email
        
        try:
            send_mail(
                subject, message, settings.EMAIL_HOST_USER, receipent_list
            )
        except Exception as e:
            print(f'Failed to send email to {instance.email} : {str(e)}')
Logic:
if created:: Only runs for new users, not updates.
token = default_token_generator.make_token(instance): Creates a unique token for the user.
activation_url = f"{settings.FRONTEND_URL}/users/activate/{instance.id}/{token}":
Constructs a URL (e.g., http://127.0.0.1:8000/users/activate/1/abcd1234) using FRONTEND_URL from settings.
Email:
subject: "Activate Your Account".
message: Greeting with a clickable activation link (note: \\n\\n should be \n\n for proper newlines).
receipent_list = instance.email: Should be a list, e.g., [instance.email].
Sent from settings.EMAIL_HOST_USER (your Gmail).

updated views.py:
# users/views.py (partial update)
def signup(request):
    if request.method == 'GET':
        form = CustomRegisterForm()
    if request.method == 'POST':
        form = CustomRegisterForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)  # Prevent immediate save to handle password hashing
            user.set_password(form.cleaned_data.get('password1'))  # Hash the password
            user.is_active = False  # Disable user until activation
            user.save()
            messages.success(request, "A confirmation mail sent, please check your email")
        else:
            print("Form is not valid")
            messages.error(request, "Account Creation failed")
    return render(request, 'registration/register.html', {'form': form})

Changes:
Added user.is_active = False: Sets the user as inactive after signup.
Updated success message: Indicates an email was sent for activation.

added # task_management/.env (partial update)
FRONTEND_URL=http://127.0.0.1:8000/ in .env and # task_management/settings.py (partial update)
FRONTEND_URL = config('FRONTEND_URL')

we stil need to add views after user clicks the link

11.6 Login with authentication form

previously we used Html form, now we will use djangos built in authentication form ,
updated forms.py: 
# users/forms.py
from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User
from tasks.forms import StyledFormMixin
from django.contrib.auth.forms import AuthenticationForm

class RegisterForm(UserCreationForm):
    class Meta:
        model = User
        fields = ['username', 'first_name', 'last_name', 'password1', 'password2', 'email']
        
    def __init__(self, *args, **kwargs):
        super(UserCreationForm, self).__init__(*args, **kwargs)
        for fieldname in ['username', 'password1', 'password2']:
            self.fields[fieldname].help_text = None
            
class CustomRegisterForm(StyledFormMixin, forms.ModelForm):
    password1 = forms.CharField(widget=forms.PasswordInput)
    password2 = forms.CharField(widget=forms.PasswordInput)
    
    class Meta:
        model = User
        fields = ['username', 'first_name', 'last_name', 'password1', 'password2', 'email']

    def clean_email(self):
        email = self.cleaned_data.get('email')
        if not email:
            raise forms.ValidationError("Email is required.")
        if User.objects.filter(email=email).exists():
            raise forms.ValidationError("This email is already associated with an account")
        return email
        
    def clean_username(self):
        username = self.cleaned_data.get('username')
        if not username:
            raise forms.ValidationError("Username is required.")
        if User.objects.filter(username=username).exists():
            raise forms.ValidationError("Username already Exists")
        return username
    
    def clean_password1(self):
        password1 = self.cleaned_data.get('password1')
        errors = []
        if not password1:
            errors.append("Password is required.")
        if len(password1) < 8:
            errors.append("Password must be at least 8 characters long.")
        if not any(char.isupper() for char in password1):
            errors.append("Password must contain at least one uppercase letter.")
        if not any(char.isdigit() for char in password1):
            errors.append("Password must contain at least one number.")
        if not any(char in '!@#$%^&*()' for char in password1):
            errors.append("Password must contain at least one special character (e.g., !@#$%^&*()).")
        if errors:
            raise forms.ValidationError(errors)
        return password1
    
    def clean(self):
        cleaned_data = super().clean()
        password1 = cleaned_data.get('password1')
        password2 = cleaned_data.get('password2')
        if password1 and password2 and password1 != password2:
            raise forms.ValidationError("Password Do Not Match")
        return cleaned_data

class LoginForm(StyledFormMixin, AuthenticationForm):
    def __init__(self, *arg, **kwarg):
        super().__init__(*arg, **kwarg)
New Form (LoginForm):
Inherits from StyledFormMixin and AuthenticationForm.
Fields: Automatically includes username and password from AuthenticationForm.
__init__: Calls the parent constructor to initialize the form, applying StyledFormMixin styling (e.g., border-2 border-gray-300 ...).
Replaces manual username/password inputs with Django’s authentication logic.

updated views.py for sign_in:

# users/views.py (partial update)
from users.forms import RegisterForm, CustomRegisterForm, LoginForm
from django.contrib import messages  # Already imported

def sign_in(request):
    form = LoginForm()
    if request.method == "POST":
        form = LoginForm(data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            messages.success(request, "Login success")  # Fixed typo: messages.success
            return redirect('home')
    return render(request, "registration/signin.html", {'form': form})

Form Initialization:
form = LoginForm(): Creates an empty form for GET requests.
form = LoginForm(data=request.POST): Binds POST data to the form for validation.
Logic:
GET: Displays the login form.
POST:
Validates the form using AuthenticationForm’s built-in logic (checks username/password against the database).
If valid: Retrieves the authenticated user with form.get_user(), logs them in with login(request, user), shows a success message, and redirects to 'home'.
If invalid: Redisplays the form with errors (handled by the template).
Template: Passes {'form': form} to signin.html.


updated signin.html:
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign In</title>
    <link rel="stylesheet" href="{% static "css/output.css" %}">
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4 max-w-md">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Sign In to Authentication System</h2>
        <div>
            {% if error %}
                <p class="bg-red-600 text-white py-2 px-4 rounded mb-4">{{ error }}</p>
            {% endif %}
        </div>
        <form method="POST" action="" class="space-y-4">
            {% csrf_token %}
            {{ form }}
            <button type="submit" class="bg-rose-500 text-white py-2 px-3 rounded-md hover:bg-rose-600">Sign In</button>
        </form>
    </div>
</body>
</html>

Replaced manual inputs (<input name="username">, <input name="password">) with {{ form }}.
Removed error handling logic since form.errors now manages invalid login attempts.
Template:
{{ form }}: Renders the LoginForm fields (username and password) with styling from StyledFormMixin.
Errors: Displays form errors (e.g., “Invalid login”) if authentication fails.
Styling: Uses Tailwind CSS from output.css (e.g., bg-gray-100, max-w-md).